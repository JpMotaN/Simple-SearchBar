name: Release to Foundry

on:
  release:
    types: [published]   # dispara quando o Release é publicado (não draft)
  workflow_dispatch: {}  # permite rodar manualmente

permissions:
  contents: write        # ESSENCIAL para anexar/atualizar assets no release

jobs:
  publish:
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      TAG:  ${{ github.event.release.tag_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure jq & zip
        run: |
          sudo apt-get update
          sudo apt-get install -y jq zip curl

      # Extrai 0.1.0 a partir de v0.1.0
      - name: Parse version from tag
        id: v
        run: |
          RAW_TAG="${TAG:-${GITHUB_REF_NAME}}"
          CLEAN="${RAW_TAG#v}"
          echo "version=${CLEAN}" >> "$GITHUB_OUTPUT"

      # Checa module.json base por campos obrigatórios
      - name: Validate base module.json
        run: |
          test -f module.json || (echo "module.json not found at repo root" && exit 1)
          jq -e '.id and .title and .compatibility.minimum and .compatibility.verified' module.json >/dev/null \
            || (echo "Missing required fields in module.json (id/title/compatibility)" && exit 1)

      # Gera module.json da versão do Release (manifest/download apontando para a TAG)
      - name: Build versioned module.json (for release)
        run: |
          VERSION="${{ steps.v.outputs.version }}"
          MANIFEST_URL="https://github.com/${REPO}/releases/download/${TAG}/module.json"
          DOWNLOAD_URL="https://github.com/${REPO}/releases/download/${TAG}/cursed-energy-${VERSION}.zip"

          jq --arg v "$VERSION" --arg dl "$DOWNLOAD_URL" --arg man "$MANIFEST_URL" \
             '.version=$v | .download=$dl | .manifest=$man' \
             module.json > /tmp/module.json

          echo "Final module.json:"
          cat /tmp/module.json

      # Cria o ZIP do módulo (ajuste exclusões conforme seu repo)
      - name: Create ZIP artifact
        run: |
          VERSION="${{ steps.v.outputs.version }}"
          ZIP="cursed-energy-${VERSION}.zip"
          zip -r "$ZIP" . \
            -x ".git/*" ".github/*" "node_modules/*"
          echo "ZIP=$ZIP" >> $GITHUB_ENV

      # Anexa module.json (da /tmp) + zip ao Release publicado
      - name: Upload assets to GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}               # explicita o token
          tag_name: ${{ github.event.release.tag_name }}   # vX.Y.Z
          files: |
            /tmp/module.json
            ${{ env.ZIP }}

      # Aguarda o asset ficar disponível (evita 404 quando a API do Foundry buscar o manifest)
      - name: Wait for manifest asset to be available
        run: |
          URL="https://github.com/${REPO}/releases/download/${TAG}/module.json"
          echo "Waiting for $URL"
          for i in {1..12}; do
            CODE=$(curl -s -o /dev/null -w "%{http_code}" -L "$URL")
            echo "Try $i -> $CODE"
            [ "$CODE" = "200" ] && exit 0
            sleep 5
          done
          echo "Manifest asset not reachable in time"
          exit 1

      # Publica no Foundry (Package Repository)
      - name: Publish to Foundry (marketplace action)
        uses: cs96and/FoundryVTT-release-package@v1
        with:
          package-token: ${{ secrets.FOUNDRY_PACKAGE_TOKEN }}  # crie esse Secret
          manifest-url: https://github.com/${{ github.repository }}/releases/download/${{ github.event.release.tag_name }}/module.json
          # dry-run: true  # descomente para testar sem publicar
